//import org.gradle.internal.logging.text.StyledTextOutput 
//import org.gradle.internal.logging.text.StyledTextOutput.Style

apply plugin: 'java'

 repositories {
        mavenCentral()
	maven {
		url ( "http://clojars.org/repo")
		}
	}

configurations {
  compile
  compile2.extendsFrom compile
  compile3.extendsFrom compile
}
ext {
	htsjdkVersion = '2.18.2'
	}

def group1 = [ group: 'com.github.samtools', name: 'htsjdk', version: ext.htsjdkVersion]

dependencies {
	compile group1
        compile group: 'com.beust', name: 'jcommander', version: '1.64'
 	compile2 group: 'javax.xml.bind', name: 'jaxb-api', version: '2.4.0-b180830.0359'
	compile3 group: 'org.clojars.chapmanb', name: 'bigwig', version: 'r39'

}

class JarFile
	{
	private final String repo;
	String server;
	boolean test=false;
	JarFile(final String repo) {
		this.repo = repo;
		}
	JarFile setTest() {
		this.test=true;
		return this;
		}
	JarFile setServer(String s) {
		this.server=s;
		return this;
		}
	@Override
	public int hashCode() { return this.repo.hashCode();}
	@Override
	public boolean equals(Object o) {
		if(o==this) return true;
		if(o==null || !(o instanceof JarFile)) return false;
		return this.repo.equals(JarFile.class.cast(o).repo);
		}
	@Override
	public String toString() {
		return this.repo;
		}
	private String[] split() {
		return this.repo.split("[/]");
		}
	String getGroup() { return split()[0];}
	String getArctifact() { return split()[1];}
	String getVersion() { return split()[3];}
	
	public String getServer() {
		return this.server==null?"http://central.maven.org/maven2":this.server;
		}
	
	public String getUrl() {
		return getServer() + getRelativeFile();
		}
	
	public String getRelativeDirectory() {
		return getGroup().replace('.','/')+"/"+getArctifact();
		}
	public String getRelativeFile() {
		return getRelativeDirectory()+"/"+getArctifact()+getVersion()+".jar";
		}
	public void download(project)
		{
		File f= new File(""+getRelativeFile());
		if(!f.exist())
			{
			project.ant.mkdir(f.getParent());
			project.ant.get(
				url:getUrl(),
				file: getRelativeFile();
				);
			}
		}
	}

final Map<String,Library> libraries = new HashMap<>();

class Library
	{
	private final Set<JarFile> files = new HashSet<>();
	Library() {
		}
	Library add(String s) {
		return this.add(new JarFile(s));
		}
	Library add(JarFile f) {
		this.files.add(f);
		return this;
		}
	Library add(Library L) {
		if(L==this) {
			this.files.addAll(L.files);
			}
		return this;
		}
	}

libraries.put("htsjdk",new Library().
	add("com.github.samtools:htsjdk:jar:2.18.2").
	add("commons-logging:commons-logging:jar:1.1.1").
	add("gov.nih.nlm.ncbi:ngs-java:jar:2.9.0").
	add("org.apache.commons:commons-jexl:jar:2.1.1").
	add("org.apache.commons:commons-compress:jar:1.4.1").
	add("org.tukaani:xz:jar:1.5").
	add("org.xerial.snappy:snappy-java:jar:1.1.4")
	);
libraries.put("jcommander",new Library().
	add("com.beust:jcommander:jar:1.72")
	);
libraries.put("testng",new Library().
	add(libraries.get("jcommander")).
	add(new JarFile("org.testng:testng:jar:6.14.3").setTest())
	);

// https://stackoverflow.com/questions/28498688


public class CompileJVarkit extends DefaultTask {
	String mainClass = ''
	String srcDir =''
	String tmpDir = ""
	String distDir = ""	
	String docDir = ""
	String jdkTarget = "11"
	String jdkSource = "11"
	String configName = "compile"
	
	CompileJVarkit() {
		def baseDir = this.getProject().projectDir.getPath();
		this.srcDir = baseDir + "/src/main/java"
		this.tmpDir = baseDir + "/tmp"
		this.distDir = baseDir + "/dist"
		this.docDir = baseDir + "/docs"
		String jvm = java.lang.System.getProperty("jvarkit.target",null);
		if(jvm!=null && !jvm.isEmpty()) {
			jdkTarget = jvm;
			jdkSource = jvm;
			}
		}
	String getMainPackage() {
		String s= this.mainClass;
		int dollar = s.indexOf('$');
		if(dollar!=-1) s=s.substring(0,dollar);
		int dot = s.lastIndexOf('.');
		if(dot==-1) return "";
		return s.substring(0,dot);
		}
	String getMainJavaSource() {
		String s = this.mainClass;
		int dollar = s.indexOf('$');
		if(dollar!=-1) s=s.substring(0,dollar);
		s = this.srcDir + "/" + s.replace('.','/')+".java";
		return s;
		}
	String getAntInclude() {
		String s= this.getMainJavaSource();
		int slash = s.lastIndexOf('/');
		return "**"+s.substring(slash);	
		}
	public String toString() {
		return 	""+this.getName()+" "+this.mainClass;
		}
	
	public String getGitHash() {
	    try {
		def stdout = new ByteArrayOutputStream()
		    project.exec {
			commandLine 'git', 'rev-parse', '--short', 'HEAD'
			standardOutput = stdout
		    }
		    return stdout.toString().trim()
		}
	    catch(Exception err) { return "undefined";}
	    }

	def getConfiguration() {
		//System.err.println("SEACHING "+ this.configName);
		//project.configurations.each{ System.err.println("conf : "+it.name); } 
		def c= project.configurations.find{it.name == this.configName}
		//System.err.println("GOT::"+this.configName +" =  "+c);
		if(c==null) throw new GradleException("Cannot find config "+this.configName+" "+c);
		
		return c;	
		}	


	 @TaskAction
	 void doIt() {

		

		/** prepare directories */
		ant.mkdir(dir:"${this.tmpDir}/META-INF")
		ant.mkdir(dir:"${this.distDir}")
		

		/** copy main source */
		ant.mkdir(dir:"${this.tmpDir}/" + this.getMainPackage().replace('.','/') )
		ant.copy(
			file: this.getMainJavaSource(),
			todir:"${this.tmpDir}/" + this.getMainPackage().replace('.','/')
			)
		/* compile sources */
		//System.err.println("JAVA_PATH="+getConfiguration().asPath);
		ant.javac(
			destdir: this.tmpDir,
			srcdir: this.srcDir,
			includeantruntime:false,
			failonerror: true,
			fork: true,
			classpath : getConfiguration().asPath,
			target: this.jdkTarget,
			source: this.jdkSource
			)  {
				include(name: this.getAntInclude())
				 compilerarg(value:'-Xlint')
			}
	
		/* shall we download Sequence Ontology ? */
		File soTreeClassFile = new File("${this.tmpDir}/com/github/lindenb/jvarkit/util/so/SequenceOntologyTree.class");
		if(soTreeClassFile.exists())
			{
			ant.mkdir(dir:"${this.tmpDir}/META-INF/so")
			final File soOwlFile = new File( this.getProject().projectDir.getPath()+"/src/main/resources/so/so-simple.owl");
			if(!soOwlFile.exists())
				{
				System.err.println("download to "+soOwlFile);
				ant.mkdir(dir:soOwlFile.parent)
				ant.get(
					src:"https://github.com/The-Sequence-Ontology/SO-Ontologies/raw/master/so-simple.owl",
					verbose:true,
					dest:soOwlFile
					);
				}
			System.err.println("copy to "+soOwlFile);
			ant.copy(
				file: soOwlFile,
				todir:"${this.tmpDir}/META-INF/so"
				)
			}

		this.getConfiguration().files.each {
			ant.unzip(src:it,dest:this.tmpDir,overwrite:true)
			}

		ant.jar(destfile: this.distDir+"/"+this.getName()+".jar",
			basedir:this.tmpDir
			){
 			 manifest {
				attribute(name:"Main-Class",value:this.mainClass)
				attribute(name:"Htsjdk-Version", value: project.ext.htsjdkVersion)
				attribute(name:"Git-Hash",value: getGitHash())
				}
			}
		//remove tmpDir
		ant.delete( dir :  this.tmpDir )
		// done : https://stackoverflow.com/questions/14516693/
		project.logger.lifecycle("jar file generated :" + this.distDir+"/${this.name}.jar")

		/* generate doc */
		ant.java(
			jar :  this.distDir+"/${this.name}.jar" , fork: true
			) {
			jvmarg(value: "-Djvarkit.doc.dir=${this.docDir}");
			arg(value: "--help")
			arg(value: "--helpFormat")
			arg(value: "make-doc")
			}

		}
	}

String biostar2java(int i) {
	return "com.github.lindenb.jvarkit.tools.biostar.Biostar"+i;
	}

task("vcfhead", type: CompileJVarkit) { mainClass = 'com.github.lindenb.jvarkit.tools.misc.VcfHead' }
task("vcftail", type: CompileJVarkit) {
		mainClass = 'com.github.lindenb.jvarkit.tools.misc.VcfTail'
		configName='compile2'
		}
task("vcffilterso", type: CompileJVarkit) {
		mainClass = 'com.github.lindenb.jvarkit.tools.vcffilterso.VcfFilterSequenceOntology'
		configName='compile2'
		}
task("addlinearindextobed", type: CompileJVarkit) { mainClass = 'com.github.lindenb.jvarkit.tools.misc.AddLinearIndexToBed' }
task("biostar105754", type: CompileJVarkit) {
		mainClass = biostar2java(105754)
		configName='compile3'
		}
